#网络编程总结

    提到网络编程，想必绕不开的必定是，TCP/IP UDP 了吧

##1.TCP/IP，UDP是什么
TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。    

 TCP/IP协议存在于OS中，网络服务通过OS提供，在OS中增加支持TCP/IP的系统调用——Berkeley套接字，如Socket，Connect，Send，Recv等
 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。如图：


![](http://my.csdn.net/uploads/201204/10/1334044049_2497.jpg)
 TCP/IP协议族包括运输层、网络层、链路层，而socket所在位置如图，Socket是应用层与TCP/IP协议族通信的中间软件抽象层。
 这几个层之间理解起来有些复杂，大家可以先看看瞎摆弄的理解

    物理层关心的是如何把电气信号变成一段报文；数据链路层关心的是mac地址、vlan、优先级等；网络层关心的是ip地址，下一跳ip；传输层关心的是端口资源；应用层关心的是报文组装、解析、渲染、存储、执行等等。   （转自网络）

	我想在我们初学者中，多加关注上三层就可以啦

![](http://my.csdn.net/uploads/201204/10/1334044170_5136.jpg)
--------------------------------------------
#2.Socket套接字是什么 
-------------------------------------------
 socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –> 读写write/read –> 关闭close”模式来操作。Socket就是该模式的一个实现，        socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）.
   白了Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

       注意：其实socket也没有层的概念，它只是一个facade设计模式的应用，让编程变的更简单。是一个软件抽象层。在网络编程中，我们大量用的都是通过socket实现的
       
       
       
       
       



socket的基本操作
1、socket()数
2、bind()函数
3、listen()、connect()函数
4、accept()函数
5、read()、write(),recv()，send（）函数等
6、close()函数
关于以上函数我特别特别想说的就是5
#特别的两个函数！！！
###特别需要注意的点
       send函数

 ssize_t  send(int  socket, const  void  *buffer, size_t length, int flags);

      不论是客户端还是服务器应用程序都用send函数来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。
参数：
 第一个参数指定发送端套接字描述符；
 第二个参数指明一个存放应用程序要发送数据的缓冲区；
 第三个参数指明实际要发送的数据的字节数；
 第四个参数用于改变函数的行为。
0：与write()无异，一般置0
MSG_DONTROUTE：告诉内核，目标主机在本地网络，不用查路由表
MSG_DONTWAIT：将单个I／O操作设置为非阻塞模式
MSG_OOB：指明发送的是带外信息
 
这里只描述同步Socket的send函数的执行流程。当调用该函数时，send先比较待发送数据的长度len和套接字s的发送缓冲的长度，如果len大于s的发送缓冲区的长度，该函数返回SOCKET_ERROR；如果len小于或者等于s的发送缓冲区的长度，那么send先检查协议是否正在发送s的发送缓冲中的数据，如果是就等待协议把数据发送完，如果协议还没有开始发送s的发送缓冲中的数据或者s的发送缓冲中没有数据，那么send就比较s的发送缓冲区的剩余空间和len，如果len大于剩余空间大小send就一直等待协议把s的发送缓冲中的数据发送完，如果len小于剩余空间大小send就仅仅把buf中的数据 copy到剩余空间里（注意并不是send把s的发送缓冲中的数据传到连接的另一端的，而是协议传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里）。
        如果send函数copy数据成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。
注意： 
 send函数把buf中的数据成功copy到s的发送缓冲的剩余空间里后它就返回了，但是此时这些数据并不一定马上被传到连接的另一端。如果协议在后续的传送过程中出现网络错误的话，那么下一个Socket函数就会返回SOCKET_ERROR。（每一个除send外的Socket函数在执行的最开始总要先等待套接字的发送缓冲中的数据被协议传送完毕才能继续，如果在等待时出现网络错误，那么该Socket函数就返回SOCKET_ERROR）
 在Unix系统下，如果send在等待协议传送数据时网络断开的话，调用send的进程会接收到一个SIGPIPE信号，进程对该信号的默认处理是进程终止。

     recv函数

 ssize_t recv(int socket, void *buffer, size_t length, int flags);

 不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。 
 第一个参数指定接收端套接字描述符；
 第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；
 第三个参数指明buf的长度；
 第四个参数用于改变函数的行为。
0：与read()相同，一般置0
MSG_DONTWAIT：将单个I／O操作设置为非阻塞模式
MSG_OOB：指明发送的是带外信息；在网络上有两种类型的数据包，正常包和带外包。带外包可以通过检验一个TCP/IP包头的一个特定标志来决定。
MSG_PEEK： 可以查看可读的信息，在接收数据后不会将这些数据丢失；从输入数据中取数。数据拷入缓冲区，但不从输入队列中移走。函数返回当前准备接收的字节数。
MSG_WAITALL：通知内核直到读到请求的数据字节数时，才返回。

        这里只描述同步Socket的recv函数的执行流程。当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR；如果s的发送缓冲中没有数据或者数据被协议成功发送完毕后，recv则去检查套接字s的接收缓冲区，如果s接收缓冲区中没有数据或者协议正在接收数据，那么recv就一直等待，直到协议把数据接收完毕。当协议把数据接收完毕，recv函数就把s的接收缓冲中的数据copy到buf中（注意协议接收到的数据可能大于buf的长度，所以在这种情况下要调用几次recv函数才能把s的接收缓冲中的数据copy完。recv函数仅仅是copy数据，真正的接收数据是协议来完成的），recv函数返回其实际copy的字节数。如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。
 注意：
在Unix系统下，如果recv函数在等待协议接收数据时网络断开了，那么调用recv的进程会接收到一个SIGPIPE信号，进程对该信号的默认处理是进程终止。这与send函数一样，我们可以捕获该信号，在程序退出前做一些我们需要的处理。
 
根据上面的说明理解下面一段话：
发送方与接收方没有定制协议的情况下，接收方不可能知道发送方是否已经发送完毕，如果想要在这种情况下实现接收方接收发送方多次send()数据可以在recv时加个参数，让它只是看看有没有数据到达，recv最后那个参数设为MSG_OOB就可以，当发现有数据到时，你先Sleep一下，至于多长时间就要看实际情况，一般几十个毫秒就绝对够了，然后，你再recv一下，这次最后那个参数为MSG_WAITALL就可以，这样就一次性接收完毕




贴一个大佬的博客 @[大佬的](http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html)